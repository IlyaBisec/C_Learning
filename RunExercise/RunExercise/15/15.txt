1. Напишите программу, являющуюся примером применения алгоритма sort() 
к массиву типа float. Значения вводятся пользователем, результат работы выводится на экран.

*2. Примените алгоритм sort() к массиву слов, введенных пользователем, выведите результат.
Используйте push_back() для добавления слов, а опе- ратор [] и size() — для вывода их на экран.

*3. Начните с создания списка целых чисел. Используйте два обычных (не обратных) итератора:
один для продвижения в прямом направлении, дру- гой для продвижения в обратном направлении. 
Вставьте их в цикл while для переворачивания содержимого списка. Ради экономии нескольких
выражений можно использовать алгоритм swap() (только при этом следует убедиться, что подход
работает как с четными, так и с нечетными эле- ментами). Чтобы посмотреть, как это делают
настоящие профессионалы, взгляните на функцию reverse() в заголовочном файле ALGORITHM.

*4. Начните с класса person. Создайте мультимножество для хранения указа- телей
на объекты этого класса. Определите его с помощью функциональ- ного объекта comparePersons,
чтобы сортировка производилась автомати- чески по именам людей. Определите с полдюжины 
элементов, внесите их в мультимножество. Выведите его содержимое. Задайте имена людей таким
образом, чтобы некоторые из них совпадали. Тем самым можно бу- дет удостовериться в том,
что мультимножество может хранить несколько объектов с одинаковым ключом.

5. Заполните массив четными числами, а множество — нечетными. С помо- щью алгоритма 
merge() объедините эти контейнеры в вектор. Выведите его содержимое, чтобы удостовериться,
что слияние прошло успешно.

6. В упражнении 3 два обычных итератора использовались для переворачи- вания содержимого
контейнера. Теперь используйте один прямой и один обратный контейнер для выполнения того
же задания, на сей раз в приме- нении к вектору.

7. В примере PLUSAIR мы показали применение версии accumulate() с четырь- мя аргументами.
Перепишите этот пример, используя версию с тремя ар- гументами.

8. Алгоритм copy() можно использовать для копирования последовательно- стей в контейнере.
Тем не менее нужно внимательно следить за тем, что- бы целевая последовательность не
перекрывала исходную. Напишите программу, позволяющую производить копирование 
последовательностей внутри контейнера. Допустим, пользователь вводит значения
first1, last1 и first2. Осуществляйте в программе проверку того, что последователь- ность,
перекрывающая другую, сдвигается налево, а не направо. (Напри- мер, можно сдвигать
некоторые данные из позиции 10 в позицию 9, но не в позицию 11.) Так делается потому, 
что copy() начинает работу с самого крайнего элемента слева.

9. В табл. 15.10 мы привели все предопределенные функциональные объек- ты C++.
В программе PLUSAIR показали, как применять функциональ- ный объект plus<>() 
с алгоритмом accumulate(). В том примере не было необходимости в передаче каких-либо 
аргументов в функциональный
объект, но иногда по логике работы программы это требуется. Оказывает- ся, 
в данном случае нельзя просто указать аргумент в скобках, как мы привыкли делать
Вместо этого нужно использовать специальный «адап- тер функции», 
называющийся bind1dt или bind2nd, для связывания аргу- мента с
функциональным объектом. Пусть, например, мы ищем строку SearchName
в строковом контейнере names. В этом случае необходимо писать такое выражение:
ptr = find_if(names.begin(), names.end(), bind2nd(equal_to<string>(), SearchName));

10. Здесь аргументами bind2nd, в свою очередь, являются equal_to<>() 
и Search- Name. Это выражение возвращает итератор, указывающий на первую 
стро- ку в контейнере, равную SearchName. Напишите программу, в которой
ис- пользуется подобное выражение для поиска строки в строковом контейнере. 
На экран должна выводиться позиция SearchName в контейнере.
